### **React'te `useRef` Hook'u Nedir ve Ne Ä°Ã§in KullanÄ±lÄ±r?**

`useRef`, React Hook'larÄ±ndan biridir ve genellikle aÅŸaÄŸÄ±daki amaÃ§larla kullanÄ±lÄ±r:

1. **DOM ElemanlarÄ±na DoÄŸrudan EriÅŸim:** 
   - React'te genellikle DOM elemanlarÄ±nÄ± kontrol etmek yerine state kullanÄ±lÄ±r. Ancak bazÄ± durumlarda bir DOM elemanÄ±na doÄŸrudan eriÅŸim gerekebilir (Ã¶rneÄŸin, odaklama veya metin seÃ§imi).
   
2. **Referans (Referans DeÄŸeri) Saklama:**
   - `useRef`, bileÅŸen yeniden render edilse bile deÄŸiÅŸmeden kalan bir referans saklar.
   - Bu, deÄŸiÅŸkenlerin yeniden render sÄ±rasÄ±nda kaybolmasÄ±nÄ± Ã¶nlemek iÃ§in kullanÄ±lÄ±r.

3. **Yeniden Render Tetiklemeden DeÄŸer Saklama:**
   - `useRef` ile saklanan deÄŸerler deÄŸiÅŸtiÄŸinde bile bileÅŸen yeniden render edilmez.

---

### **`useRef` NasÄ±l Ã‡alÄ±ÅŸÄ±r?**

`useRef`, bir `ref` objesi dÃ¶ndÃ¼rÃ¼r. Bu obje ÅŸu ÅŸekildedir:

```javascript
const myRef = useRef(initialValue);
```

- `myRef.current`: Objenin iÃ§indeki mevcut deÄŸeri temsil eder.
- `initialValue`: `useRef` ilk kez Ã§aÄŸrÄ±ldÄ±ÄŸÄ±nda bu deÄŸer atanÄ±r.

---

## **`useRef` ile DOM ManipÃ¼lasyonu**

Bir DOM elemanÄ±na doÄŸrudan eriÅŸim gerektiÄŸinde `useRef` kullanÄ±lÄ±r.

### **Ã–rnek: Bir Input AlanÄ±na Odaklanma**

```jsx
import React, { useRef } from "react";

function InputFocus() {
  const inputRef = useRef();

  const handleFocus = () => {
    inputRef.current.focus(); // DOM elementine doÄŸrudan eriÅŸim ve odaklanma
  };

  return (
    <div>
      <input ref={inputRef} type="text" placeholder="Type something..." />
      <button onClick={handleFocus}>Focus Input</button>
    </div>
  );
}

export default InputFocus;
```

#### **NasÄ±l Ã‡alÄ±ÅŸÄ±r?**
- `ref` Ã¶zelliÄŸi ile bir input elemanÄ±na referans atanÄ±r.
- `inputRef.current` ile bu DOM elemanÄ±na eriÅŸilir ve `focus` metodu Ã§aÄŸrÄ±lÄ±r.

---

## **`useRef` ile DeÄŸer Saklama**

`useRef`, bir bileÅŸenin yeniden render edilmesi sÄ±rasÄ±nda deÄŸeri koruyabilir.

### **Ã–rnek: SayaÃ§ UygulamasÄ±**

```jsx
import React, { useRef, useState } from "react";

function Counter() {
  const countRef = useRef(0);
  const [renderCount, setRenderCount] = useState(0);

  const increment = () => {
    countRef.current += 1; // useRef ile deÄŸer artÄ±rÄ±lÄ±r
    console.log(`Count: ${countRef.current}`);
  };

  const reRender = () => {
    setRenderCount(renderCount + 1); // BileÅŸen yeniden render edilir
  };

  return (
    <div>
      <p>Count: {countRef.current}</p>
      <button onClick={increment}>Increment</button>
      <button onClick={reRender}>Re-render</button>
    </div>
  );
}

export default Counter;
```

#### **NasÄ±l Ã‡alÄ±ÅŸÄ±r?**
- `countRef.current` artÄ±rÄ±ldÄ±ÄŸÄ±nda bileÅŸen yeniden render edilmez.
- Sadece React state (`renderCount`) deÄŸiÅŸtiÄŸinde render gerÃ§ekleÅŸir.

---

## **`useRef` ile Formlarda KullanÄ±m**

Bir form elemanÄ±na eriÅŸmek ve deÄŸerlerini kontrol etmek iÃ§in kullanÄ±labilir.

### **Ã–rnek: Unkontrollierte Form**

```jsx
import React, { useRef } from "react";

function UncontrolledForm() {
  const nameRef = useRef();
  const emailRef = useRef();

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(`Name: ${nameRef.current.value}, Email: ${emailRef.current.value}`);
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Name:
        <input type="text" ref={nameRef} />
      </label>
      <br />
      <label>
        Email:
        <input type="email" ref={emailRef} />
      </label>
      <br />
      <button type="submit">Submit</button>
    </form>
  );
}

export default UncontrolledForm;
```

---

## **`useRef` ile Performans Optimizasyonu**

`useRef`, bileÅŸenin yeniden render edilmesi sÄ±rasÄ±nda referanslarÄ±n deÄŸiÅŸmemesini saÄŸlayarak performans artÄ±ÅŸÄ± saÄŸlar.

### **Ã–rnek: ZamanlayÄ±cÄ±**

```jsx
import React, { useRef, useState } from "react";

function Timer() {
  const [count, setCount] = useState(0);
  const timerRef = useRef(null);

  const startTimer = () => {
    if (!timerRef.current) {
      timerRef.current = setInterval(() => {
        setCount((prev) => prev + 1);
      }, 1000);
    }
  };

  const stopTimer = () => {
    clearInterval(timerRef.current);
    timerRef.current = null;
  };

  return (
    <div>
      <h1>Timer: {count}</h1>
      <button onClick={startTimer}>Start</button>
      <button onClick={stopTimer}>Stop</button>
    </div>
  );
}

export default Timer;
```

#### **NasÄ±l Ã‡alÄ±ÅŸÄ±r?**
- `timerRef` zamanlayÄ±cÄ± referansÄ±nÄ± tutar.
- ZamanlayÄ±cÄ± durdurulduÄŸunda referans sÄ±fÄ±rlanÄ±r (`null`).

---

## **`useRef` KullanÄ±mÄ±nda Dikkat Edilmesi Gerekenler**

1. **DeÄŸer DeÄŸiÅŸikliÄŸi Render Tetiklemez:**
   - `useRef` iÃ§indeki bir deÄŸer deÄŸiÅŸtiÄŸinde bileÅŸen yeniden render edilmez.
   
2. **DOM DÄ±ÅŸÄ± DeÄŸerler iÃ§in KullanÄ±labilir:**
   - DeÄŸiÅŸkenleri bir bileÅŸenin yaÅŸam dÃ¶ngÃ¼sÃ¼ boyunca saklamak iÃ§in kullanÄ±labilir.

3. **BaÅŸlangÄ±Ã§ DeÄŸeri:** 
   - Ä°lk deÄŸer `null` veya baÅŸlangÄ±Ã§ta atanmÄ±ÅŸ bir deÄŸer olabilir.

---

## **SonuÃ§**

`useRef`, React'te hem DOM manipÃ¼lasyonu hem de bileÅŸen yaÅŸam dÃ¶ngÃ¼sÃ¼ boyunca deÄŸiÅŸmeyecek referanslar saklamak iÃ§in gÃ¼Ã§lÃ¼ bir araÃ§tÄ±r. Performans optimizasyonu ve DOM ile Ã§alÄ±ÅŸma gerektiren durumlarda kullanÄ±mÄ± son derece faydalÄ±dÄ±r.

EÄŸer daha fazla Ã¶rnek Ã§Ã¶zmek istersen, birlikte daha fazla pratik yapabiliriz! ğŸ˜Š